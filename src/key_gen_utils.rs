
use aes::Aes256;
use cipher::Key;
use ed25519_dalek::Keypair;
use rand::Rng;
use rand_old::rngs::OsRng;
use sha2::{Digest, Sha256};
use zeroize::{Zeroize, ZeroizeOnDrop};

/// Generate a new pair of 256bit EdDSA keys from the OS's randomness source.
pub fn generate_new_signing_keys() -> Keypair {
    Keypair::generate(&mut OsRng {})
}

/// Generate a new 256bit AES encryption key from the OS's randomness source.
pub fn generate_new_encryption_key() -> Key<Aes256> {
    // Randomly generate an array of 32 bytes, then convert it into a 256bit key value.
    rand::thread_rng().gen::<[u8; 32]>().into()
}

/// This struct is used to create and store derivative keys from a master key.
/// It is only capable of handling and generating 256bit length keys.
///
/// The new key is generated by hashing a master key with a randomly selected salt value.
/// The salt is stored in this struct alongside the derived key, allowing the key to be re-derived later.
///
/// The derived key must be kept private and should be discarded after use.
/// It is safe (and standard) to publicize the salt value.
#[derive(Debug, Eq, PartialEq, Zeroize, ZeroizeOnDrop)]
pub struct DerivedKeyData {
    /// The derived key.
    /// This should be kept private, but compromising this derived key doesn't compromise the master key.
    pub derived_key: Key<Aes256>,

    /// The salt that was hashed with the master key.
    /// This can be publicized without compromising either the master or derived key.
    pub key_salt: u64,
}

impl DerivedKeyData {
    /// Derive a new key from the provided master key by hashing it with a random 64bit salt value:
    /// `derived_key = sha256([master_key][key_salt])`
    pub fn derive_new_from(master_key: &Key<Aes256>) -> Self {
        // Randomly generate a salt value to hash with the provided key.
        let key_salt: u64 = rand::thread_rng().gen();

        // Compute the derived key and return it alongside the salt that was used.
        let derived_key = Self::re_derive_from(master_key, key_salt);
        DerivedKeyData { derived_key, key_salt }
    }

    /// Re-derive a key from the provided master key by hashing it with a specific salt value:
    /// `derived_key = sha256([master_key][key_salt])`
    pub fn re_derive_from(master_key: &Key<Aes256>, key_salt: u64) -> Key<Aes256> {
        // Hash the provided master key with the randomly generated salt.
        let mut key_generator = Sha256::new();
        key_generator.update(master_key);
        key_generator.update(key_salt.to_be_bytes());
        key_generator.finalize()
    }
}

#[cfg(test)]
mod tests {
    use super::DerivedKeyData;
    use crate::key_gen_utils;

    #[test]
    fn ensure_key_derivation_is_deterministic() {
        // ===== Arrange ===== //
        let test_key = key_gen_utils::generate_new_encryption_key();

        // ===== Act ===== //
        let DerivedKeyData { derived_key, key_salt } = DerivedKeyData::derive_new_from(&test_key);
        let rederived_key = DerivedKeyData::re_derive_from(&test_key, key_salt);

        // ===== Assert ===== //
        assert_eq!(derived_key, rederived_key, "master_key = '{test_key:?}', salt = '{key_salt:?}'");
    }
}
